// Min path between every pair of nodes in directed graph
// G[i][j] initially needs weight of edge (i, j) or INF
// be careful with multiedges and loops when assigning to G
int G[MAX_N][MAX_N];
void floyd() {  // O(N^3)
  forn(k, N) forn(i, N) if (G[i][k] != INF) forn(j, N) if (G[k][j] != INF)
      G[i][j] = min(G[i][j], G[i][k] + G[k][j]);
}
bool inNegCycle(int v) { return G[v][v] < 0; }
// checks if there's a neg. cycle in path from a to b
bool hasNegCycle(int a, int b) {
  forn(i, N) if (G[a][i] != INF && G[i][i] < 0 && G[i][b] != INF) return true;
  return false;
}
